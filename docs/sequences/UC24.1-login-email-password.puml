@startuml UC24.1 Login With Email And Password
!theme plain
skinparam backgroundColor #FEFEFE
skinparam sequenceMessageAlign center
skinparam BoxPadding 10

title UC24.1 - Login With Email And Password

actor "User" as User
boundary "Login Page" as FE
participant ":API Gateway\n(Express Router)" as Router
participant ":validateMiddleware" as ValidateMW
participant ":authController" as AuthCtrl
participant ":authService" as AuthSvc
participant ":userService" as UserSvc
participant ":tokenService" as TokenSvc
database "MongoDB\n(Users Collection)" as UserDB
database "MongoDB\n(Tokens Collection)" as TokenDB

== User Navigates to Login Page ==

User -> FE: Navigate to /login
activate FE

FE -> FE: Display login form\n(email & password fields)
FE --> User: Show login form
deactivate FE

== User Submits Credentials ==

User -> FE: Enter email & password\nClick "Login" button
activate FE

FE -> FE: Validate form inputs\n(client-side)

note right of FE
  Client-side checks:
  - Email format valid
  - Password not empty
  - Min length requirements
end note

alt Client Validation Failed
    FE --> User: Show validation errors\n(inline form errors)
end

FE -> Router: POST /v1/auth/login\nBody: {email, password}
activate Router

== Validation Layer ==

Router -> ValidateMW: validate(authValidation.login)
activate ValidateMW

ValidateMW -> ValidateMW: Validate request body:\n- email (string, required)\n- password (string, required)

note right of ValidateMW
  Joi Schema:
  {
    email: Joi.string().required(),
    password: Joi.string().required()
  }
end note

alt Validation Failed
    ValidateMW --> Router: 400 Bad Request\n{error: validation details}
    Router --> FE: Validation error
    FE --> User: "Invalid email or password format"
else Validation Passed
    ValidateMW --> Router: Next()
    deactivate ValidateMW
end

== Authentication Process ==

Router -> AuthCtrl: login(req, res)
activate AuthCtrl

AuthCtrl -> AuthCtrl: Extract email & password\nfrom req.body

AuthCtrl -> AuthSvc: loginUserWithEmailAndPassword(email, password)
activate AuthSvc

== Verify User Credentials ==

AuthSvc -> UserSvc: getUserByEmail(email)
activate UserSvc

UserSvc -> UserDB: User.findOne({ email })\n.select('+password')
activate UserDB

note right of UserDB
  MongoDB query with password field
  (normally excluded by toJSON plugin)
end note

UserDB --> UserSvc: Return user document\n(with hashed password)
deactivate UserDB

alt User Not Found
    UserSvc --> AuthSvc: Return null
    deactivate UserSvc
    
    AuthSvc --> AuthCtrl: throw ApiError(401,\n"Incorrect email or password")
    AuthCtrl --> Router: 401 Unauthorized
    Router --> FE: Error response
    FE --> User: "Incorrect email or password"
end

UserSvc --> AuthSvc: Return user object
deactivate UserSvc

== Password Verification ==

AuthSvc -> AuthSvc: user.isPasswordMatch(password)

note right of AuthSvc
  Compares plain password with
  bcrypt hashed password using:
  bcrypt.compare(password, user.password)
end note

alt Password Mismatch
    AuthSvc --> AuthCtrl: throw ApiError(401,\n"Incorrect email or password")
    AuthCtrl --> Router: 401 Unauthorized
    Router --> FE: Error response
    FE --> User: "Incorrect email or password"
end

AuthSvc --> AuthCtrl: Return authenticated user
deactivate AuthSvc

== Generate Authentication Tokens ==

AuthCtrl -> TokenSvc: generateAuthTokens(user)
activate TokenSvc

TokenSvc -> TokenSvc: Generate Access Token\n(JWT, expires in 30 minutes)

note right of TokenSvc
  Access Token Payload:
  {
    sub: user._id,
    iat: timestamp,
    exp: timestamp + 30min,
    type: "access"
  }
  
  Signed with JWT_SECRET
end note

TokenSvc -> TokenSvc: Generate Refresh Token\n(JWT, expires in 30 days)

note right of TokenSvc
  Refresh Token Payload:
  {
    sub: user._id,
    iat: timestamp,
    exp: timestamp + 30days,
    type: "refresh"
  }
end note

TokenSvc -> TokenDB: Token.create({\n  token: refreshToken,\n  user: user._id,\n  type: "refresh",\n  expires: expiryDate\n})
activate TokenDB

TokenDB -> TokenDB: Save refresh token\nfor later validation
TokenDB --> TokenSvc: Token saved
deactivate TokenDB

TokenSvc --> AuthCtrl: Return {\n  access: { token, expires },\n  refresh: { token, expires }\n}
deactivate TokenSvc

== Success Response ==

AuthCtrl -> AuthCtrl: Prepare response:\n{ user, tokens }

note right of AuthCtrl
  User object (sanitized):
  {
    _id, name, email,
    role, type, avatar,
    isEmailVerified,
    createdAt, updatedAt
  }
  (password excluded by toJSON plugin)
end note

AuthCtrl --> Router: 200 OK\n{ user, tokens }
deactivate AuthCtrl

Router --> FE: Success response
deactivate Router

== Update Client State ==

FE -> FE: Store tokens:\n- accessToken in memory/state\n- refreshToken in secure storage\n  (HttpOnly cookie or secure storage)

FE -> FE: Store user info in state\n(Redux/Context/Zustand)

FE -> FE: Set Authorization header:\nBearer <accessToken>

FE --> User: Redirect to dashboard/home
deactivate FE

note right of User
  User is now logged in
  Subsequent API calls include:
  Authorization: Bearer <accessToken>
end note

@enduml
